#Mysql
##1.优化 
### 1.1优化方式
```
1.设置索引
2.使用EXPLAIN 来查看你的 SELECT 查询
3.不要使用表达式作为查询条件
4.尽量使用in运行符来替代or运算
5.条件列表值如果连续使用between替代in
6.无重复记录的结果集使用union all合并
7.有条件使用where就不使用having
8.使用like操作符时通配符要放在右侧
9.储存引擎选择：如果数据表需要事务处理，应该考虑使用 InnoDB，因为它完全符合 ACID 特性。
  如果不需要事务处理，使用默认存储引擎 MyISAM 是比较明智的
  分表分库，主从。
  对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索
  引
  应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全
  表扫描
  应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫
  描
  应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，
  将导致引擎放弃使用索引而进行全表扫描
  Update 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调用会引起明显的
  性能消耗，同时带来大量日志
  对于多张大数据量（这里几百条就算大了）的表 JOIN，要先分页再 JOIN，否则逻辑读会很高，
  性能很差。
```
###1.2 执行顺序
```
from–where–group by–having–select–order by
from:需要从哪个数据表检索数据
where:过滤表中数据的条件
group by:如何将上面过滤出的数据分组
having:对上面已经分组的数据进行过滤的条件
select:查看结果集中的哪个列，或列的计算结果
order by :按照什么样的顺序来查看返回的数据
```
###1.3 Innodb MyISAM MEMORY 
```
表级锁： 开销小，加锁快；不会出现死锁(因为 MyISAM 会一次性获得 SQL 所需的全部锁)；锁定粒度大，发生锁冲突的概率最高
并发度最低。

行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低
并发度也最高。

页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，
并发度一般

对于 InnoDB 表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以
选择 InnoDB 表的理由。但在个别特殊事务中，也可以考虑使用表级锁。

第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不
仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考
虑使用表锁来提高该事务的执行速度。

第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种
情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

这两种事务不能太多，否则，就应该考虑使用 MyISAM 表了。

表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的 web 应用；
而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。

```

